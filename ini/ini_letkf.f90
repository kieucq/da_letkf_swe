!
! [NOTE] This program is for creating 
! 1. an ensemble of input for a cold start run of the 
!    serial EnKF from a background file bgd.dat that
!    is generated by the program infield.f
! 2. an perfect initial condition for the true run
!    using the same bgd.dat file.
!
! [HISTORY]: Created on May 25, 2009
!
! [AUTHOR]: Chanh Q. Kieu (kieucq@atmos.umd.edu)
!
!====================================================
!
  PROGRAM cold_start_ini 
  IMPLICIT NONE
  INTEGER,PARAMETER :: nx = 114, ny = 17, nv=nx*ny
  INTEGER           :: ne,icen,jcen 
  REAL              :: dx,dy,radi,pi,cor(ny),slat,lat
  REAL              :: au(nx,ny),av(nx,ny),az(nx,ny)
  REAL              :: ut(nx,ny),vt(nx,ny),zt(nx,ny)
  REAL              :: u(nx,ny),ur(nx,ny)
  REAL              :: v(nx,ny),vr(nx,ny)
  REAL              :: z(nx,ny),zr(nx,ny)
  REAL              :: zamp,zscale
  REAL              :: bgd_err_u,bgd_err_v,bgd_err_z
  REAL(8)           :: rnd(nv)
  CHARACTER*50      :: ofile
  INTEGER           :: id,i,j,k,debug,irec
  ofile        = 'bgd_000_00:00:00.dat'
  open(10,file='../truth/infield_out.dat',status='old')
! open(11,file='ini_truth.dat')
  open(12,file='ini.dat',FORM='UNFORMATTED',ACCESS='DIRECT',RECL=nx*ny*4)
!
! initialize para
!
  irec         = 1
  pi           = 4*atan(1.)
  call input_namelist(debug,zamp,zscale,icen,jcen,bgd_err_u,bgd_err_v,bgd_err_z,dy,slat,ne)
  dx           = dy
  IF (debug.ge.1) THEN
   print*,'ini.exe: debug     = ',debug
   print*,'ini.exe: ne        = ',ne
   print*,'ini.exe: zamp      = ',zamp
   print*,'ini.exe: zscale    = ',zscale
   print*,'ini.exe: icen      = ',icen
   print*,'ini.exe: jcen      = ',jcen
   print*,'ini.exe: bgd_err_u = ',bgd_err_u
   print*,'ini.exe: bgd_err_v = ',bgd_err_v
   print*,'ini.exe: bgd_err_z = ',bgd_err_z
   print*,'ini.exe: dx        = ',dx
   print*,'ini.exe: dy     = ',dy
   print*,'ini.exe: slat   = ',slat
   read*
  ENDIF
!
! creating first an initial condition that is also used
! from the truth program as a background. 
!
  READ(10,'(6E13.6)')((u(i,j),i=1,nx),j=1,ny)
  READ(10,'(6E13.6)')((v(i,j),i=1,nx),j=1,ny)
  READ(10,'(6E13.6)')((z(i,j),i=1,nx),j=1,ny)
  WRITE(12,rec=irec)((u(i,j),i=1,nx),j=1,ny)
  irec          = irec + 1
  WRITE(12,rec=irec)((v(i,j),i=1,nx),j=1,ny)
  irec          = irec + 1
  WRITE(12,rec=irec)((z(i,j),i=1,nx),j=1,ny)
  irec          = irec + 1
!
! creating a bogus vortex... removed now to a program
! ../truth/bvortex.f90
!
!  DO j          = 1,ny
!   lat          = slat + (j-1)*dy/111e3
!   cor(j)       = 5e-5 !2*7.2e-5*sin(pi*lat/180.) 
!  ENDDO
!  DO j          = 1,ny
!   DO i         = 1,nx
!    radi        = sqrt(((i-icen)*dx)**2 + ((j-jcen)*dy)**2)
!    az(i,j)     = -zamp*exp(-(radi/zscale)**2)
!    zt(i,j)     = z(i,j) + az(i,j)
!   ENDDO
!  ENDDO
!  au            = 0.
!  av            = 0.
!  ut            = u
!  vt            = v
!  DO j          = 2,ny-1
!   DO i         = 2,nx-1
!    IF (cor(j).gt.0) THEN
!     au(i,j)    = -9.81*(az(i,j+1)-az(i,j-1))/2/dy/cor(j)
!     av(i,j)    =  9.81*(az(i+1,j)-az(i-1,j))/2/dx/cor(j)
!     ut(i,j)    = u(i,j) + au(i,j)
!     vt(i,j)    = v(i,j) + av(i,j)
!    ENDIF
!   ENDDO
!  ENDDO
!  WRITE(12,rec=irec)((ut(i,j),i=1,nx),j=1,ny)
!  irec          = irec + 1
!  WRITE(12,rec=irec)((vt(i,j),i=1,nx),j=1,ny)
!  irec          = irec + 1
!  WRITE(12,rec=irec)((zt(i,j),i=1,nx),j=1,ny)
!  irec          = irec + 1
!  WRITE(11,'(6E13.6)')((ut(i,j),i=1,nx),j=1,ny)
!  WRITE(11,'(6E13.6)')((vt(i,j),i=1,nx),j=1,ny)
!  WRITE(11,'(6E13.6)')((zt(i,j),i=1,nx),j=1,ny)
!
! creating an ensemble of +/- enhanced fields.
! It turns out that this is the germ of singulariy
! for the matrxi inversion later used by etkf
!
  DO k      = 1,ne
   PRINT*,'Creating the ensemble ',k
   CALL com_randn(nx*ny,rnd)
   ur       = RESHAPE(rnd,(/nx,ny/))*bgd_err_u
   CALL com_randn(nx*ny,rnd)
   vr       = RESHAPE(rnd,(/nx,ny/))*bgd_err_v
   CALL com_randn(nx*ny,rnd)
   zr       = RESHAPE(rnd,(/nx,ny/))*bgd_err_z
   ur       = u + ur
   vr       = v + vr
   zr       = z + zr
   id       = k 
   IF (id.le.9) THEN
    WRITE(ofile(7:7),'(1I1)')id
   ELSEIF (id.le.99)  THEN
    WRITE(ofile(6:7),'(1I2)')id
   ELSEIF (id.le.999) THEN
    WRITE(ofile(5:7),'(1I3)')id
   ELSE
    PRINT*,'Too many ensemble members...stop'
    STOP
   ENDIF
   OPEN(13,file=ofile,status='unknown')
   WRITE(13,'(6E13.6)')((ur(i,j),i=1,nx),j=1,ny)
   WRITE(13,'(6E13.6)')((vr(i,j),i=1,nx),j=1,ny)
   WRITE(13,'(6E13.6)')((zr(i,j),i=1,nx),j=1,ny)
   CLOSE(13)
   WRITE(12,rec=irec)((ur(i,j),i=1,nx),j=1,ny)
   irec          = irec + 1
   WRITE(12,rec=irec)((vr(i,j),i=1,nx),j=1,ny)
   irec          = irec + 1
   WRITE(12,rec=irec)((zr(i,j),i=1,nx),j=1,ny)
   irec          = irec + 1
  ENDDO
  END 


  SUBROUTINE input_namelist(debug,zamp,zscale,icen,jcen,bgd_err_u,bgd_err_v,bgd_err_z,dy,slat,ne)
  INCLUDE "../registry/swe.inc"
  RETURN
  END


  SUBROUTINE com_randn(ndim,var)
  USE mt19937
  IMPLICIT NONE
  INTEGER,INTENT(IN) :: ndim
  REAL(8),INTENT(OUT) :: var(1:ndim)
  REAL(8) :: rnd(2),pi
  INTEGER :: idate(8)
  INTEGER :: i,iseed
  LOGICAL,SAVE :: first=.true.
  pi = 4.*atan(1.)

  IF (first) THEN
    CALL DATE_AND_TIME(VALUES=idate)
    iseed = idate(8) + idate(7)*1000
    CALL init_genrand(iseed)
    first=.false.
  END IF

  IF( MOD(ndim,2)==0 ) THEN
    DO i=1,ndim/2
      rnd(1) = genrand_res53()
      rnd(2) = genrand_res53()
      var(i*2-1) = sqrt( -2.0d0 * log( rnd(1) ) ) * sin( 2.0d0*pi*rnd(2) )
      var(i*2) = sqrt( -2.0d0 * log( rnd(1) ) ) * cos( 2.0d0*pi*rnd(2) )
    END DO
  ELSE
    DO i=1,(ndim-1)/2
      rnd(1) = genrand_res53()
      rnd(2) = genrand_res53()
      var(i*2-1) = sqrt( -2.0d0 * log( rnd(1) ) ) * sin( 2.0d0*pi*rnd(2) )
      var(i*2) = sqrt( -2.0d0 * log( rnd(1) ) ) * cos( 2.0d0*pi*rnd(2) )
    END DO
    rnd(1) = genrand_res53()
    rnd(2) = genrand_res53()
    var(ndim) = sqrt( -2.0d0 * log( rnd(1) ) ) * sin( 2.0d0*pi*rnd(2) )
  END IF
  RETURN
END SUBROUTINE com_randn
